<!DOCTYPE html>
<html>

<head>
    <title>On-Screen Keyboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <style>
        .keyboard {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 5px;
            margin-top: 20px;
        }

        .key {
            padding: 10px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            text-align: center;
            cursor: pointer;
        }

        .output-container {
            margin-top: 20px;
            font-size: 16px;
            border: 1px solid #ccc;
            padding: 10px;
            min-height: 100px;
            /* Adjust as needed */
            width: 80%;
            /* Adjust as needed */
            overflow-y: auto;
        }

        textarea {
            margin-top: 20px;
            width: 80%;
            /* Adjust as needed */
            height: 100px;
            /* Adjust as needed */
        }

        .active {
            background-color: lightblue;
        }
    </style>
</head>

<body>
    <h1>On-Screen Keyboard</h1>
    <textarea id="textInput"></textarea>
    <div class="keyboard"></div>
    <div class="output-container" id="output"></div>
    <script>
        const keyboard = document.querySelector('.keyboard');
        const outputElement = document.querySelector('#output');
        const textInput = document.querySelector('#textInput');
        let latexOutput = '';
        let subscriptMode = false;
        let superscriptMode = false;

        const keys = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'Subscript', 'SuperScript', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', 'a', 's', 'sa', 're1', 're2', 'ga1', 'ga2', 'ma1', 'ma2', ';', 'z', 'x', 'c', 'pa', 'dha1', 'dha2', 'm', ',', '.', '/', ' ', 'Add Line', '(', ')'];

        keys.forEach(key => {
            const keyElement = document.createElement('div');
            keyElement.classList.add('key');
            keyElement.textContent = key;
            keyElement.addEventListener('click', () => {
                const cursorPosition = textInput.selectionStart; // Get cursor position
                const textBeforeCursor = textInput.value.substring(0, cursorPosition);
                const textAfterCursor = textInput.value.substring(cursorPosition);

                if (key === 'Add Line') {
                    textInput.value = textBeforeCursor + '\\overline{}' + textAfterCursor; // Add \overline{} template
                    latexOutput = textBeforeCursor + '\\overline{}' + textAfterCursor;
                    renderLatexOutput();
                    textInput.selectionStart = cursorPosition + 10; // Move cursor position
                    textInput.selectionEnd = cursorPosition + 10;
                } else if (key === 'Subscript') {
                    subscriptMode = true;
                    keyElement.classList.add('active');
                    superscriptMode = false;
                    document.querySelector('.keyboard .key:nth-child(12)').classList.remove('active');
                    textInput.value = textBeforeCursor + '_{}' + textAfterCursor; // Modified: Use _{} template for subscript
                    latexOutput = textBeforeCursor + '_{}' + textAfterCursor;
                    textInput.selectionStart = cursorPosition + 2; // Modified: Move cursor position
                    textInput.selectionEnd = cursorPosition + 2;
                } else if (key === 'SuperScript') {
                    superscriptMode = true;
                    keyElement.classList.add('active');
                    subscriptMode = false;
                    document.querySelector('.keyboard .key:nth-child(11)').classList.remove('active');
                    textInput.value = textBeforeCursor + '^{}' + textAfterCursor; // Modified: Use ^{} template for superscript
                    latexOutput = textBeforeCursor + '^{}' + textAfterCursor;
                    textInput.selectionStart = cursorPosition + 2; // Modified: Move cursor position
                    textInput.selectionEnd = cursorPosition + 2;
                }
                else if (key === ' ') {
                    textInput.value = textBeforeCursor + ' ' + textAfterCursor; // Add space
                    latexOutput = textBeforeCursor + ' ' + textAfterCursor;
                    renderLatexOutput();
                    textInput.selectionStart = cursorPosition + 1; // Move cursor position
                    textInput.selectionEnd = cursorPosition + 1;
                } else {
                    if (subscriptMode) {
                        textInput.value = textBeforeCursor + `_${key}` + textAfterCursor; // Append subscript template
                        latexOutput = textBeforeCursor + `_${key}` + textAfterCursor;
                        textInput.selectionStart = cursorPosition + key.length + 2; // Move cursor position
                        textInput.selectionEnd = cursorPosition + key.length + 2;
                    } else if (superscriptMode) {
                        textInput.value = textBeforeCursor + `^${key}` + textAfterCursor; // Append superscript template
                        latexOutput = textBeforeCursor + `^${key}` + textAfterCursor;
                        textInput.selectionStart = cursorPosition + key.length + 2; // Move cursor position
                        textInput.selectionEnd = cursorPosition + key.length + 2;
                    } else {
                        textInput.value = textBeforeCursor + key + textAfterCursor; // Append key to text input
                        latexOutput = textBeforeCursor + key + textAfterCursor;
                        textInput.selectionStart = cursorPosition + key.length; // Move cursor position
                        textInput.selectionEnd = cursorPosition + key.length;
                    }
                    renderLatexOutput();
                }
            });
            keyboard.appendChild(keyElement);
        });

        function renderLatexOutput() {
            outputElement.innerHTML = '$$' + latexOutput + '$$';
            MathJax.Hub.Queue(["Typeset", MathJax.Hub, outputElement]);
        }

        // Update latexOutput when user edits the text input
        textInput.addEventListener('input', () => {
            latexOutput = textInput.value;
            renderLatexOutput();
        });
    </script>
</body>

</html>
